<?xml version="1.0" encoding="utf-8"?><span>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>mono-api-gc.html</title>
    <style type="text/css">
//<![CDATA[

SCALAR(0x55eb08c9ad00)
   
//]]>//
</style>
</head>
<body>
<div class="mapi-docs">
<h1>Garbage Collector Interface</h1>

<h1>Public Interface</h1>

	<p />The public interface of the Mono GC is fairly limited, and
	its the only one that embedders should be using:

<h3>Garbage Collector</h3>

<a name="api:mono_gc_collect"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_collect</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_collect (int generation)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>generation</i></td><td> GC generation identifier</td></tr></tbody></table>             <div class="mapi-section">Description</div>
             <div>
<p />
 Perform a garbage collection for the given generation, higher numbers
 mean usually older objects. Collecting a high-numbered generation
 implies collecting also the lower-numbered generations.
 The maximum value for <i>generation</i> can be retrieved with a call to
 <code>mono_gc_max_generation</code>, so this function is usually called as:
<p />
 <code>mono_gc_collect (mono_gc_max_generation ());</code></div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_collection_count"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_collection_count</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">int
mono_gc_collection_count (int generation)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>generation</i></td><td> a GC generation number</td></tr></tbody></table>             <div class="mapi-section">Return value</div>
             <div>	 the number of garbage collections
</div>
             <div class="mapi-section">Description</div>
             <div>
<p />
 Get how many times a garbage collection has been performed
 for the given <i>generation</i> number.
<p /></div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_max_generation"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_max_generation</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">int
mono_gc_max_generation (void)

</div>
            <p />
             <div class="mapi-section">Return value</div>
             <div>	 the maximum generation number.
</div>
             <div class="mapi-section">Description</div>
             <div>
<p />
 Get the maximum generation number used by the current garbage
 collector. The value will be 0 for the Boehm collector, 1 or more
 for the generational collectors.
<p /></div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_get_generation"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_get_generation</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">int
mono_gc_get_generation  (MonoObject *object)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>object</i></td><td> a managed object</td></tr></tbody></table>             <div class="mapi-section">Return value</div>
             <div>	 a garbage collector generation number
</div>
             <div class="mapi-section">Description</div>
             <div>
<p />
 Get the garbage collector's generation that <i>object</i> belongs to.
 Use this has a hint only.
<p /></div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_get_heap_size"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_get_heap_size</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">int64_t
mono_gc_get_heap_size (void)

</div>
            <p />
             <div class="mapi-section">Return value</div>
             <div>	 the size of the heap in bytes
</div>
             <div class="mapi-section">Description</div>
             <div>
<p />
 Get the amount of memory used by the garbage collector.
<p /></div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_get_used_size"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_get_used_size</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">int64_t
mono_gc_get_used_size (void)

</div>
            <p />
             <div class="mapi-section">Return value</div>
             <div>	 the amount of memory used in bytes
</div>
             <div class="mapi-section">Description</div>
             <div>
<p />
 Get the approximate amount of memory used by managed objects.
<p /></div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_walk_heap"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_walk_heap</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">int
mono_gc_walk_heap (int flags, MonoGCReferences callback, void *data)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>flags</i></td><td> flags for future use</td></tr><tr><td><i>callback</i></td><td> a function pointer called for each object in the heap</td></tr><tr><td><i>data</i></td><td> a user data pointer that is passed to callback</td></tr></tbody></table>             <div class="mapi-section">Return value</div>
             <div>	 a non-zero value if the GC doesn't support heap walking
</div>
             <div class="mapi-section">Description</div>
             <div>
 This function can be used to iterate over all the live objects in the heap;
 for each object, <i>callback</i> is invoked, providing info about the object's
 location in memory, its class, its size and the objects it references.
 For each referenced object its offset from the object address is
 reported in the offsets array.
 The object references may be buffered, so the callback may be invoked
 multiple times for the same object: in all but the first call, the size
 argument will be zero.
 Note that this function can be only called in the <code>MONO_GC_EVENT_PRE_START_WORLD</code>
 profiler event handler.</div>
        </div><!--mapi-description -->
    </div><!--height container -->

<h3>Reference Queues</h3>

</div> <!-- class=mapi  -->

<a name="api:mono_gc_reference_queue_add"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_reference_queue_add</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">gboolean
mono_gc_reference_queue_add (MonoReferenceQueue *queue, MonoObject *obj, void *user_data)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>queue</i></td><td> the queue to add the reference to.</td></tr><tr><td><i>obj</i></td><td> the object to be watched for collection</td></tr><tr><td><i>user_data</i></td><td> parameter to be passed to the queue callback</td></tr></tbody></table>             <div class="mapi-section">Return value</div>
             <div>	 <code>FALSE</code> if the queue is scheduled to be freed.
</div>
             <div class="mapi-section">Description</div>
             <div>
<p />
 Queue an object to be watched for collection, when the <i>obj</i> is
 collected, the callback that was registered for the <i>queue</i> will
 be invoked with <i>user_data</i> as argument.
<p /></div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_reference_queue_free"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_reference_queue_free</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_reference_queue_free (MonoReferenceQueue *queue)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>queue</i></td><td> the queue that should be freed.</td></tr></tbody></table>             <div class="mapi-section">Description</div>
             <div>
<p />
 This operation signals that <i>queue</i> should be freed. This operation is deferred
 as it happens on the finalizer thread.
<p />
 After this call, no further objects can be queued. It's the responsibility of the
 caller to make sure that no further attempt to access queue will be made.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_reference_queue_new"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_reference_queue_new</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">MonoReferenceQueue*
mono_gc_reference_queue_new (mono_reference_queue_callback callback)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>callback</i></td><td> callback used when processing collected entries.</td></tr></tbody></table>             <div class="mapi-section">Return value</div>
             <div>	 the new queue.
</div>
             <div class="mapi-section">Description</div>
             <div>
<p />
 Create a new reference queue used to process collected objects.
 A reference queue let you add a pair of (managed object, user data)
 using the <code>mono_gc_reference_queue_add</code> method.
<p />
 Once the managed object is collected <i>callback</i> will be called
 in the finalizer thread with 'user data' as argument.
<p />
 The callback is called from the finalizer thread without any locks held.
 When an AppDomain is unloaded, all callbacks for objects belonging to it
 will be invoked.
<p /></div>
        </div><!--mapi-description -->
    </div><!--height container -->

<h3>SGen Bridge</h3>

	<p />The bridge is a mechanism for SGen to let clients override
	the death of some unreachable objects.  We use it in monodroid
	to do garbage collection across the Mono and Java heaps.

	<p />The client can designate some objects as &quot;bridged&quot;, which
	means that they participate in the bridge processing step once
	SGen considers them unreachable, i.e., dead.  Bridged objects
	must be registered for finalization.

	<p />When SGen is done marking, it puts together a list of all
	dead bridged objects and then does a strongly connected
	component analysis over their object graph.  That graph will
	usually contain non-bridged objects, too.
	
	<p />The output of the SCC analysis is passed to the
	`cross_references()` callback.  It is expected to set the
	`is_alive` flag on those strongly connected components that it
	wishes to be kept alive.  The value of `is_alive` will be
	ignored on any SCCs which lack bridges.
	
	<p />In monodroid each bridged object has a corresponding Java
	mirror object.  In the bridge callback it reifies the Mono
	object graph in the Java heap so that the full, combined
	object graph is now instantiated on the Java side.  Then it
	triggers a Java GC, waits for it to finish, and checks which
	of the Java mirror objects are still alive.  For those it sets
	the `is_alive` flag and returns from the callback.
	
	<p />The SCC analysis is done while the world is stopped, but
	the callback is made with the world running again.  Weak links
	to bridged objects and other objects reachable from them are
	kept until the callback returns, at which point all links to
	bridged objects that don't have `is_alive` set are nulled.
	Note that weak links to non-bridged objects reachable from
	bridged objects are not nulled.  This might be considered a
	bug.

<div class="mapi-header">
enum {
        SGEN_BRIDGE_VERSION = 5
};
        
typedef enum {
        /* Instances of this class should be scanned when computing the transitive dependency among bridges. E.g. List of object*/
        GC_BRIDGE_TRANSPARENT_CLASS,
        /* Instances of this class should not be scanned when computing the transitive dependency among bridges. E.g. String*/
        GC_BRIDGE_OPAQUE_CLASS,
        /* Instances of this class should be bridged and have their dependency computed. */
        GC_BRIDGE_TRANSPARENT_BRIDGE_CLASS,
        /* Instances of this class should be bridged but no dependencies should not be calculated. */
        GC_BRIDGE_OPAQUE_BRIDGE_CLASS,
} MonoGCBridgeObjectKind;

typedef struct {
        mono_bool is_alive;     /* to be set by the cross reference callback */
        int num_objs;
        MonoObject *objs [MONO_ZERO_LEN_ARRAY];
} MonoGCBridgeSCC;

typedef struct {
        int src_scc_index;
        int dst_scc_index;
} MonoGCBridgeXRef;

typedef struct {
        int bridge_version;
        /*
         * Tells the runtime which classes to even consider when looking for
         * bridged objects.  If subclasses are to be considered as well, the
         * subclass check must be done in the callback.
         */
        MonoGCBridgeObjectKind (*bridge_class_kind) (MonoClass *klass);
        /*
         * This is only called on objects for whose classes
         * `bridge_class_kind()` returned `XXX_BRIDGE_CLASS`.
         */
        mono_bool (*is_bridge_object) (MonoObject *object);
        void (*cross_references) (int num_sccs, MonoGCBridgeSCC **sccs, int num_xrefs, MonoGCBridgeXRef *xrefs);
} MonoGCBridgeCallbacks;
</div>

</div> <!-- class=mapi  -->

<a name="api:mono_gc_register_bridge_callbacks"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_register_bridge_callbacks</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_register_bridge_callbacks (MonoGCBridgeCallbacks *callbacks)

</div>
            <p />
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_wait_for_bridge_processing"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wait_for_bridge_processing</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wait_for_bridge_processing (void)

</div>
            <p />
        </div><!--mapi-description -->
    </div><!--height container -->

<h3>Write Barriers</h3>

	<p />SGen is a concurrent and generational GC, features which require
	tracking changes to the state of the heap. This is achieved through
	write barriers. Whenever native code is changing the state of the
	heap by storing references into another managed object, it needs to
	do it using this write barrier API.

</div> <!-- class=mapi  -->

<a name="api:mono_gc_wbarrier_arrayref_copy"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wbarrier_arrayref_copy</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wbarrier_arrayref_copy (void* dest_ptr, /*const*/ void* src_ptr, int count)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>dest_ptr</i></td><td> destination slot address</td></tr><tr><td><i>src_ptr</i></td><td> source slot address</td></tr><tr><td><i>count</i></td><td> number of references to copy</td></tr></tbody></table>             <div class="mapi-section">Description</div>
             <div>
 Copies <i>count</i> references from one array to another, executing a write
 barrier if needed.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_wbarrier_generic_nostore"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wbarrier_generic_nostore</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wbarrier_generic_nostore (void* ptr)

</div>
            <p />
             <div class="mapi-section">Description</div>
             <div>
 Executes a write barrier for an address, informing the GC that
 the reference stored at that address has been changed.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_wbarrier_generic_store"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wbarrier_generic_store</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wbarrier_generic_store (void* ptr, MonoObject* value)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>ptr</i></td><td> address of field</td></tr><tr><td><i>obj</i></td><td> object to store</td></tr></tbody></table>             <div class="mapi-section">Description</div>
             <div>
 Stores the <i>value</i> object inside the field represented by <i>ptr</i>,
 executing a write barrier if needed.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_wbarrier_generic_store_atomic"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wbarrier_generic_store_atomic</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wbarrier_generic_store_atomic (void *ptr, MonoObject *value)

</div>
            <p />
             <div class="mapi-section">Description</div>
             <div>
 Same as <code>mono_gc_wbarrier_generic_store</code> but performs the store
 as an atomic operation with release semantics.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_wbarrier_object_copy"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wbarrier_object_copy</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wbarrier_object_copy (MonoObject* obj, MonoObject *src)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>obj</i></td><td> destination object</td></tr><tr><td><i>src</i></td><td> source object</td></tr></tbody></table>             <div class="mapi-section">Description</div>
             <div>
 Copies contents of <i>src</i> to <i>obj</i>, executing any necessary write
 barriers.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_wbarrier_set_arrayref"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wbarrier_set_arrayref</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wbarrier_set_arrayref (MonoArray *arr, void* slot_ptr, MonoObject* value)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>arr</i></td><td> array containing the destination slot</td></tr><tr><td><i>slot_ptr</i></td><td> address of slot inside the array</td></tr><tr><td><i>value</i></td><td> reference to the object to be stored</td></tr></tbody></table>             <div class="mapi-section">Description</div>
             <div>
 Stores an object reference inside an array of objects, executing a write
 barrier if needed.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
</div> <!-- class=mapi  -->

<a name="api:mono_gc_wbarrier_set_field"></a>
<div class="mapi">
    <div class="mapi-entry "><code>mono_gc_wbarrier_set_field</code></div>
    <div class="mapi-height-container">
        <div class="mapi-ptr-container"></div>
        <div class="mapi-description">
            <div class="mapi-ptr"></div>

            <div class="mapi-declaration mapi-section">Syntax</div>
            <div class="mapi-prototype">void
mono_gc_wbarrier_set_field (MonoObject *obj, void* field_ptr, MonoObject* value)

</div>
            <p />
            <div class="mapi-section">Parameters</div>
            <table class="mapi-parameters"><tbody><tr><td><i>obj</i></td><td> object containing the destination field</td></tr><tr><td><i>field_ptr</i></td><td> address of field inside the object</td></tr><tr><td><i>value</i></td><td> reference to the object to be stored</td></tr></tbody></table>             <div class="mapi-section">Description</div>
             <div>
 Stores an object reference inside another object, executing a write barrier
 if needed.</div>
        </div><!--mapi-description -->
    </div><!--height container -->
   </div></div></body></html></span>