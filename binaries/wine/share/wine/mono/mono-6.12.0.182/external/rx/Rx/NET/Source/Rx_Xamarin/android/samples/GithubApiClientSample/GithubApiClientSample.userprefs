<Properties>
  <MonoDevelop.Ide.Workspace />
  <MonoDevelop.Ide.Workbench>
    <Pads>
      <Pad Id="ProjectPad">
        <State expanded="True" />
      </Pad>
      <Pad Id="ClassPad">
        <State selected="True" />
      </Pad>
      <Pad Id="MonoDevelop.Debugger.WatchPad">
        <State />
      </Pad>
    </Pads>
  </MonoDevelop.Ide.Workbench>
  <MonoDevelop.Ide.DebuggingService.Breakpoints>
    <BreakpointStore />
  </MonoDevelop.Ide.DebuggingService.Breakpoints>
  <MonoDevelop.Ide.DebuggingService.PinnedWatches>
    <Watch file="../../../../../../../../../../home/atsushi/svn/mono/external/rx/Rx/NET/Source/System.Reactive.PlatformServices/Reactive/Concurrency/ConcurrencyAbstractionLayerImpl.cs" line="16" offsetX="702" offsetY="225" expression="internal class /*Default*/ConcurrencyAbstractionLayerImpl : IConcurrencyAbstractionLayer&#xA;    {&#xA;        public IDisposable StartTimer(Action&lt;object&gt; action, object state, TimeSpan dueTime)&#xA;        {&#xA;            return new Timer(action, state, Normalize(dueTime));&#xA;        }&#xA;&#xA;        public IDisposable StartPeriodicTimer(Action action, TimeSpan period)&#xA;        {&#xA;            //&#xA;            // MSDN documentation states the following:&#xA;            //&#xA;            //    &quot;If period is zero (0) or negative one (-1) milliseconds and dueTime is positive, callback is invoked once;&#xA;            //     the periodic behavior of the timer is disabled, but can be re-enabled using the Change method.&quot;&#xA;            //&#xA;            if (period &lt;= TimeSpan.Zero)&#xA;                throw new ArgumentOutOfRangeException(&quot;period&quot;);&#xA;&#xA;            return new PeriodicTimer(action, period);&#xA;        }&#xA;&#xA;        public IDisposable QueueUserWorkItem(Action&lt;object&gt; action, object state)&#xA;        {&#xA;            System.Threading.ThreadPool.QueueUserWorkItem(_ =&gt; action(_), state);&#xA;            return Disposable.Empty;&#xA;        }&#xA;&#xA;#if USE_SLEEP_MS&#xA;        public void Sleep(TimeSpan timeout)&#xA;        {&#xA;            System.Threading.Thread.Sleep((int)Normalize(timeout).TotalMilliseconds);&#xA;        }&#xA;#else&#xA;        public void Sleep(TimeSpan timeout)&#xA;        {&#xA;            System.Threading.Thread.Sleep(Normalize(timeout));&#xA;        }&#xA;#endif&#xA;&#xA;        public IStopwatch StartStopwatch()&#xA;        {&#xA;#if !NO_STOPWATCH&#xA;            return new StopwatchImpl();&#xA;#else&#xA;            return new DefaultStopwatch();&#xA;#endif&#xA;        }&#xA;&#xA;        public bool SupportsLongRunning&#xA;        {&#xA;            get { return true; }&#xA;        }&#xA;&#xA;        public void StartThread(Action&lt;object&gt; action, object state)&#xA;        {&#xA;            new Thread(() =&gt;&#xA;            {&#xA;                action(state);&#xA;            }) { IsBackground = true }.Start();&#xA;        }&#xA;&#xA;        private static TimeSpan Normalize(TimeSpan dueTime)&#xA;        {&#xA;            if (dueTime &lt; TimeSpan.Zero)&#xA;                return TimeSpan.Zero;&#xA;&#xA;            return dueTime;&#xA;        }&#xA;&#xA;#if USE_TIMER_SELF_ROOT&#xA;&#xA;        //&#xA;        // Some historical context. In the early days of Rx, we discovered an issue with&#xA;        // the rooting of timers, causing them to get GC'ed even when the IDisposable of&#xA;        // a scheduled activity was kept alive. The original code simply created a timer&#xA;        // as follows:&#xA;        //&#xA;        //   var t = default(Timer);&#xA;        //   t = new Timer(_ =&gt;&#xA;        //   {&#xA;        //       t = null;&#xA;        //       Debug.WriteLine(&quot;Hello!&quot;);&#xA;        //   }, null, 5000, Timeout.Infinite);&#xA;        //&#xA;        // IIRC the reference to &quot;t&quot; captured by the closure wasn't sufficient on .NET CF&#xA;        // to keep the timer rooted, causing problems on Windows Phone 7. As a result, we&#xA;        // added rooting code using a dictionary (SD 7280), which we carried forward all&#xA;        // the way to Rx v2.0 RTM.&#xA;        //&#xA;        // However, the desktop CLR's implementation of System.Threading.Timer exhibits&#xA;        // other characteristics where a timer can root itself when the timer is still&#xA;        // reachable through the state or callback parameters. To illustrate this, run&#xA;        // the following piece of code:&#xA;        //&#xA;        //   static void Main()&#xA;        //   {&#xA;        //       Bar();&#xA;        //   &#xA;        //       while (true)&#xA;        //       {&#xA;        //           GC.Collect();&#xA;        //           GC.WaitForPendingFinalizers();&#xA;        //           Thread.Sleep(100);&#xA;        //       }&#xA;        //   }&#xA;        //   &#xA;        //   static void Bar()&#xA;        //   {&#xA;        //       var t = default(Timer);&#xA;        //       t = new Timer(_ =&gt;&#xA;        //       {&#xA;        //           t = null; // Comment out this line to see the timer stop&#xA;        //           Console.WriteLine(&quot;Hello!&quot;);&#xA;        //       }, null, 5000, Timeout.Infinite);&#xA;        //   }&#xA;        //&#xA;        // When the closure over &quot;t&quot; is removed, the timer will stop automatically upon&#xA;        // garbage collection. However, when retaining the reference, this problem does&#xA;        // not exist. The code below exploits this behavior, avoiding unnecessary costs&#xA;        // to root timers in a thread-safe manner.&#xA;        //&#xA;        // Below is a fragment of SOS output, proving the proper rooting:&#xA;        //&#xA;        //   !gcroot 02492440&#xA;        //    HandleTable:&#xA;        //        005a13fc (pinned handle)&#xA;        //        -&gt; 03491010 System.Object[]&#xA;        //        -&gt; 024924dc System.Threading.TimerQueue&#xA;        //        -&gt; 02492450 System.Threading.TimerQueueTimer&#xA;        //        -&gt; 02492420 System.Threading.TimerCallback&#xA;        //        -&gt; 02492414 TimerRootingExperiment.Program+&lt;&gt;c__DisplayClass1&#xA;        //        -&gt; 02492440 System.Threading.Timer&#xA;        //&#xA;        // With the USE_TIMER_SELF_ROOT symbol, we shake off this additional rooting code&#xA;        // for newer platforms where this no longer needed. We checked this on .NET Core&#xA;        // as well as .NET 4.0, and only #define this symbol for those platforms.&#xA;        //&#xA;&#xA;        class Timer : IDisposable&#xA;        {&#xA;            private Action&lt;object&gt; _action;&#xA;            private volatile System.Threading.Timer _timer;&#xA;&#xA;            public Timer(Action&lt;object&gt; action, object state, TimeSpan dueTime)&#xA;            {&#xA;                _action = action;&#xA;&#xA;                // Don't want the spin wait in Tick to get stuck if this thread gets aborted.&#xA;                try { }&#xA;                finally&#xA;                {&#xA;                    //&#xA;                    // Rooting of the timer happens through the this.Tick delegate's target object,&#xA;                    // which is the current instance and has a field to store the Timer instance.&#xA;                    //&#xA;                    _timer = new System.Threading.Timer(this.Tick, state, dueTime, TimeSpan.FromMilliseconds(System.Threading.Timeout.Infinite));&#xA;                }&#xA;            }&#xA;&#xA;            private void Tick(object state)&#xA;            {&#xA;                try&#xA;                {&#xA;                    _action(state);&#xA;                }&#xA;                finally&#xA;                {&#xA;                    SpinWait.SpinUntil(IsTimerAssigned);&#xA;                    Dispose();&#xA;                }&#xA;            }&#xA;&#xA;            private bool IsTimerAssigned()&#xA;            {&#xA;                return _timer != null;&#xA;            }&#xA;&#xA;            public void Dispose()&#xA;            {&#xA;                var timer = _timer;&#xA;                if (timer != TimerStubs.Never)&#xA;                {&#xA;                    _action = Stubs&lt;object&gt;.Ignore;&#xA;                    _timer = TimerStubs.Never;&#xA;&#xA;                    timer.Dispose();&#xA;                }&#xA;            }&#xA;        }&#xA;&#xA;        class PeriodicTimer : IDisposable&#xA;        {&#xA;            private Action _action;&#xA;            private volatile System.Threading.Timer _timer;&#xA;&#xA;            public PeriodicTimer(Action action, TimeSpan period)&#xA;            {&#xA;                _action = action;&#xA;&#xA;                //&#xA;                // Rooting of the timer happens through the this.Tick delegate's target object,&#xA;                // which is the current instance and has a field to store the Timer instance.&#xA;                //&#xA;                _timer = new System.Threading.Timer(this.Tick, null, period, period);&#xA;            }&#xA;&#xA;            private void Tick(object state)&#xA;            {&#xA;                _action();&#xA;            }&#xA;&#xA;            public void Dispose()&#xA;            {&#xA;                var timer = _timer;&#xA;                if (timer != null)&#xA;                {&#xA;                    _action = Stubs.Nop;&#xA;                    _timer = null;&#xA;&#xA;                    timer.Dispose();&#xA;                }&#xA;            }&#xA;        }&#xA;#else&#xA;        class Timer : IDisposable&#xA;        {&#xA;            //&#xA;            // Note: the dictionary exists to &quot;root&quot; the timers so that they are not garbage collected and finalized while they are running.&#xA;            //&#xA;#if !NO_HASHSET&#xA;            private static readonly HashSet&lt;System.Threading.Timer&gt; s_timers = new HashSet&lt;System.Threading.Timer&gt;();&#xA;#else&#xA;            private static readonly Dictionary&lt;System.Threading.Timer, object&gt; s_timers = new Dictionary&lt;System.Threading.Timer, object&gt;();&#xA;#endif&#xA;&#xA;            private Action&lt;object&gt; _action;&#xA;            private System.Threading.Timer _timer;&#xA;&#xA;            private bool _hasAdded;&#xA;            private bool _hasRemoved;&#xA;&#xA;            public Timer(Action&lt;object&gt; action, object state, TimeSpan dueTime)&#xA;            {&#xA;                _action = action;&#xA;                _timer = new System.Threading.Timer(Tick, state, dueTime, TimeSpan.FromMilliseconds(System.Threading.Timeout.Infinite));&#xA;&#xA;                lock (s_timers)&#xA;                {&#xA;                    if (!_hasRemoved)&#xA;                    {&#xA;#if !NO_HASHSET&#xA;                        s_timers.Add(_timer);&#xA;#else&#xA;                        s_timers.Add(_timer, null);&#xA;#endif&#xA;&#xA;                        _hasAdded = true;&#xA;                    }&#xA;                }&#xA;            }&#xA;&#xA;            private void Tick(object state)&#xA;            {&#xA;                try&#xA;                {&#xA;                    _action(state);&#xA;                }&#xA;                finally&#xA;                {&#xA;                    Dispose();&#xA;                }&#xA;            }&#xA;&#xA;            public void Dispose()&#xA;            {&#xA;                _action = Stubs&lt;object&gt;.Ignore;&#xA;&#xA;                var timer = default(System.Threading.Timer);&#xA;&#xA;                lock (s_timers)&#xA;                {&#xA;                    if (!_hasRemoved)&#xA;                    {&#xA;                        timer = _timer;&#xA;                        _timer = null;&#xA;&#xA;                        if (_hasAdded &amp;&amp; timer != null)&#xA;                            s_timers.Remove(timer);&#xA;&#xA;                        _hasRemoved = true;&#xA;                    }&#xA;                }&#xA;&#xA;                if (timer != null)&#xA;                    timer.Dispose();&#xA;            }&#xA;        }&#xA;&#xA;        class PeriodicTimer : IDisposable&#xA;        {&#xA;            //&#xA;            // Note: the dictionary exists to &quot;root&quot; the timers so that they are not garbage collected and finalized while they are running.&#xA;            //&#xA;#if !NO_HASHSET&#xA;            private static readonly HashSet&lt;System.Threading.Timer&gt; s_timers = new HashSet&lt;System.Threading.Timer&gt;();&#xA;#else&#xA;            private static readonly Dictionary&lt;System.Threading.Timer, object&gt; s_timers = new Dictionary&lt;System.Threading.Timer, object&gt;();&#xA;#endif&#xA;&#xA;            private Action _action;&#xA;            private System.Threading.Timer _timer;&#xA;&#xA;            public PeriodicTimer(Action action, TimeSpan period)&#xA;            {&#xA;                _action = action;&#xA;                _timer = new System.Threading.Timer(Tick, null, period, period);&#xA;&#xA;                lock (s_timers)&#xA;                {&#xA;#if !NO_HASHSET&#xA;                    s_timers.Add(_timer);&#xA;#else&#xA;                    s_timers.Add(_timer, null);&#xA;#endif&#xA;                }&#xA;            }&#xA;&#xA;            private void Tick(object state)&#xA;            {&#xA;                _action();&#xA;            }&#xA;&#xA;            public void Dispose()&#xA;            {&#xA;                var timer = default(System.Threading.Timer);&#xA;&#xA;                lock (s_timers)&#xA;                {&#xA;                    timer = _timer;&#xA;                    _timer = null;&#xA;&#xA;                    if (timer != null)&#xA;                        s_timers.Remove(timer);&#xA;                }&#xA;&#xA;                if (timer != null)&#xA;                {&#xA;                    timer.Dispose();&#xA;                    _action = Stubs.Nop;&#xA;                }&#xA;            }&#xA;        }&#xA;#endif&#xA;    }" liveUpdate="True" />
  </MonoDevelop.Ide.DebuggingService.PinnedWatches>
  <MonoDevelop.Ide.ItemProperties.GithubApiClientSample />
</Properties>